# -*- coding: utf-8 -*-
"""kv.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I3Gety2H0z2_3248SEyCZ4LmZSjj8gEX
"""

import pandas as pd
import numpy as np
import scipy
from scipy import signal as sig
from scipy.fft import fft, fftfreq
import matplotlib.pyplot as plt

def read_dat(n):     #чтение файлов
    m=[]
    t=[]
    with open (n) as nt:
        for line in nt:
            v=line.strip()
            l,cc,k=v.split(';')
            m.append(cc)
            t.append(k)
    return pd.DataFrame(m),pd.DataFrame(t)

def butter_bandpass(data,lowcut, highcut, fs = 256, order=5):   #фильтр баттерворда
  nyq = 0.5 * fs
  low = lowcut / nyq
  high = highcut / nyq
  b, a = sig.butter(order, [low, high], btype = 'band')
  y = sig.lfilter(b, a, data)
  return y
def chastots(d,Fs = 256,save = False):
     n = len(d)
     k = np.arange(n)
     T = n/Fs
     frq = k/T # two sides frequency range
     frq = frq[:len(frq)//2] # one side frequency range

     Y = np.fft.fft(d)/n 
     Y = Y[:n//2]
     plt.plot(frq,abs(Y)) 
     plt.xlabel('Freq (Hz)')
     plt.ylabel('|Y(freq)|')
     plt.show()
     if save:
      return frq

def cut(data,ch,len_epoch=256):
    eegg = []
    for j in range(len(ch)):
        eeg = []
        for i in range(0,len(data),len_epoch):
            eeg.append(np.array(data[ch[j]][i:i+len_epoch]))
        eegg = pd.concat([pd.DataFrame(eegg).T,pd.DataFrame(eeg).T],ignore_index = True).T
    return eegg
def inf(a):
    res = []
    mx = max(a)
    mn = min(a)
    mx_time = np.where(a == mx)[0][0]
    mn_time = np.where(a == mn)[0][0]
    res.append(mx_time)
    res.append(max(a))
    res.append(max(a) - min(a))
    res.append(gs(a))
    res.append(bs(a))
    #res.append(mx_time - mn_time)
    #res.append(max(a[0::]))
    
    return res
def butter_bandpass(data,lowcut, highcut, fs = 250, order=5):   #фильтр баттерворда
  nyq = 0.5 * fs
  low = lowcut / nyq
  high = highcut / nyq
  b, a = sig.butter(order, [low, high], btype = 'band')
  y = sig.lfilter(b, a, data)
  return y
def max_razm(data):
    data = list(data)
    ans = []
    data.remove(max(data))
    ans.append(max(data))
    data.remove(max(data))
    ans.append(max(data))
    return ans
def min_razm(data):
    data = list(data)
    ans = min(data)
    data.remove(ans)
    ans = min(data)
    return [abs(ans)]
def var(ch):
    v = np.std(ch)/np.mean(ch)
    return [v]

def max_razm_fft(data):
    f = np.abs(np.fft.rfft(data))
    ans = max(f)
    return [ans]
def min_razm_fft(data):
    f = np.abs(np.fft.rfft(data))
    ans = min(f)
    return [ans]

def max_assim_razm(data):
    ans = abs(max_razm(data)[0]-min_razm(data)[0])
    a= []
    a.append(ans)
    return a

def MSR(data):
    ans = 0
    ch = data
    ans += np.sqrt(np.sum(np.array(ch)**2) / len(ch))
    return [ans]

def wawes(ch):
    SLICE_SIZE = 256
    ans = []
    delta = 1 * 64*2//SLICE_SIZE
    teta = 4* 64*2//SLICE_SIZE
    alpha = 8 * 64*2//SLICE_SIZE
    beta = 12 * 64*2//SLICE_SIZE
    gamma = 30 * 64*2//SLICE_SIZE
    f = np.abs(np.fft.rfft(ch))
    ans += [
            np.sum(f[delta:teta]),
            np.sum(f[teta:alpha]),
            np.sum(f[alpha:beta]),
            np.sum(f[beta:gamma]),
            np.sum(f[gamma:]),
        ]
    return ans
def mean_z(a):
    new = []
    for i in range(0,len(a)-15):
        new.append(np.mean(a[i:i+15]))
    return(new)
def priz_eeg(data,len_epoch = 256,ch =1):   #признаки нужные для ЭЭГ
    all = []
    y = []
    data = np.array(data)
    for i in range(ch):
        all.append(max_razm(data[len_epoch*i:len_epoch*i+len_epoch])[1])
        all.append(min_razm(data[len_epoch*i:len_epoch*i+len_epoch])[0])
        all.append(max_razm_fft(data[len_epoch*i:len_epoch*i+len_epoch])[0])
        all.append(wawes(data[len_epoch*i:len_epoch*i+len_epoch])[1])
        all.append(wawes(data[len_epoch*i:len_epoch*i+len_epoch])[2])
        all.append(wawes(data[len_epoch*i:len_epoch*i+len_epoch])[3])
        all.append(wawes(data[len_epoch*i:len_epoch*i+len_epoch])[4])
        all.append(MSR(data[len_epoch*i:len_epoch*i+len_epoch])[0])
        all.append(inf(data[len_epoch*i:len_epoch*i+len_epoch])[2])
        y+=all
    return y
def priz_emg(data):   #признаки нужные для эмг
    all = []
    y = []
    all.append(max(data))
    all.append(np.std(data))
    all.append(max_razm(data)[1])
    all.append(max_razm(data)[0])
    all.append(min_razm(data)[0])
    b = np.abs(np.diff(data)).sum()/np.array(data).size
    all.append(b)
    c = np.sum((np.diff(data[0::][:-1]) * -np.diff(data[0::][1:]))>7000)/data[0::].size
    all.append(c)
    all.append(inf(data)[2])
    all.append(max_razm_fft(data)[0])
    y+=all
    return y
